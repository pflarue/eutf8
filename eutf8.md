## eutf8 (escaped UTF-8)

**The Problem:** How to print/log/display a byte sequence that may not be entirely valid UTF-8 encoded text, such that any valid text is correctly displayed while any non-text bytes are also mostly recognizable?  The initial motivation for this is to log/display text data received over a radio link before error correction has been applied, or when error correction routines fail.  However, it has also proven useful to log/display received data that may intentionally include an unknown mix of non-text formatting/protocol bytes, UTF-8 encoded text, and/or byte sequences resulting from data compression.

For a similar problem, but where the expected text is all printable ASCII rather than UTF-8 encoded Unicode text, see also [easc (escaped ASCII)](easc.md) encoding.

**A proposed solution:**  eutf8 (escaped UTF-8) encoded data is guaranteed to be valid UTF-8 (which is not true of arbitrary binary data), such that it can be decoded to unicode text using a UTF-8 decoder to facilitate display/printing the data.  This encoding replaces any bytes in the source data that do not represent valid UTF-8 encoded text with an escape format of `\HH`.  Here `HH` are two upper case hex digits (0-9, A-F).

`to_eutf8()` converts arbitrary byte sequences to eutf8 format, while `from_eutf8()` converts eutf8 formatted data back to the arbitrary byte sequence that it was created from.  The inputs and outputs of both of these functions are sequences of bytes, not null terminated strings.  Commonly available functions to convert UTF-8 encoded byte sequences to Unicode text must be used to convert eutf8 format byte sequences to Unicode text strings.

In the reference implementations of `to_eutf8()`, valid UTF-8 sequences that represent C0 or C1 control codes, Unicode private use characters, or Unicode noncharacters are also escaped because attempting to display/print these valid UTF-8 symbols that are not commonly found in printable text may have unexpected results.  Options available in these implementations allow the user to choose whether or not horizontal tab (\t 0x09), line feed (\n 0x0A), and carriage return (\r 0x0D) characters, all of which are C0 control codes, are escaped.  These functions can easily be modified to not escape some or all of these.  This may be useful, for example, if some subset of Unicode private use characters are expected to be present and can be correctly displayed.

Wherever a backslash (`\`) followed by zero or more UTF-8 encoded Zero Width Spaces and then two upper case hex digits is found in the raw source data, `to_eutf8()` also inserts a three byte UTF-8 encoded Zero Width Space after the backslash.  This allows `from_eutf8()` to unambiguously restore the original source data from the eutf8 data, while not changing the appearance of any valid UTF-8 text.

Just because eutf8 encoded data can be decoded to unicode text does not guarantee that it can be accurately rendered for display to the user.  Depending on the software being used and the font(s) available, display of some unicode characters may not be supported.  In this case, those characters are likely to be displayed using a generic glyph or a hex value.

If it is important for a human seeing the eutf8 encoded text to be able to distinguish between escapes of the form `\HH` and similar looking text from the raw source data (which will include a Zero Width Space after the backslash when eutf8 encoded), then additional formatting can be wrapped around all actual escapes, as done by the `tag_escapes()` function used in eutf8_test.js.  Annother alternative would be to replace all instances of Zero Width Space with some other character before printing.

### Properties and use cases for eutf8

In the following, Python syntax is used to describe the properties and usage of eutf8.  However, there is nothing Python specific about use of eutf8 encoding.  Similar `to_eutf8()` and `from_eutf8()` functions can be written in any general purpose programming language.

Where `data` may be mostly valid UTF-8 encoded text, but it contains one or more bytes of data that are not valid UTF-8, `data.decode(encoding="utf-8")` would raise a `UnicodeDecodeError`.  For this same `data`, `to_eutf8(data).decode(encoding="utf-8")` succeeds and `print(to_eutf8(data).decode(encoding="utf-8"))` produces mostly understandable text.

If `data` is valid UTF-8 encoded text with no control codes other than horizontal tab, line feed, or carriage return characters, no Unicode private-use characters, and no Unicode noncharacters, then the output of `print(data.decode(encoding="utf-8"))` looks identical to `print(to_eutf8(data).decode(encoding="utf-8"))`.  In this case, the output of `to_eutf8(data)` may be larger than `data` but usually not by much.  In the worst case for entirely valid UTF-8 encoded text, data contains only sequences of a backslash followed by two uppercase hex digits, resulting in the output of `to_eutf8(data)` being twice as large as `data`.

If `data` is mostly valid UTF-8 encoded text with a few bytes that are not valid UTF-8, then `print(to_eutf8(data).decode(encoding="utf-8"))` will show the valid UTF-8 encoded text correctly while printing `\HH` for each invalid byte.  Here `HH` are two upper case hex digits (0-9, A-F).  In this case, `to_eutf8(data)` is usually only slightly larger than `data`, because each byte that was not valid UTF-8 encoded text is replaced with a three byte escape.  Also, a three byte UTF-8 encoded Zero Width Space is added after every backslash (`\`) in `data` that is followed by zero or more UTF-8 encoded Zero Width Spaces and two upper case hex digits (0-9, A-F).

If `data` is random binary data, then `to_eutf8(data)` produces valid UTF-8 data and `to_eutf8(data).decode(encoding="utf-8")` succeeds.  In this case the output of `to_eutf8(data)` is usually slightly more than twice as large as `data`, and `print(to_eutf8(data).decode(encoding="utf-8"))` produces something that looks quite random.  This printed output mostly consists of a mix of printable ASCII characters (numbers, letters, and punctuation) and three byte escape sequences of the form `\HH`.  It may also include some non-ASCII characters such as letters from any of the alphabets that can be written in Unicode (Greek, Cyrillic, Braille, etc.) or the additional punctuation, math symbols, graphical symbols, etc. that Unicode supports.  If the software or font(s) being used do not support display of some of those non-ASCII characters, they are likely to be displayed using a generic glyph or a hex value.

In the extreme case where every byte of `data` must be escaped, then `to_eutf8(data)` is three times as long as `data`.

Because `data == from_eutf8(to_eutf8(data))`, eutf8 encoded data is also usable for storing or transmitting data that may or may not be valid UTF-8 encoded text.  An example where this might be useful is to write binary data of unknown format to a log file.  This allows the log file to be viewed using most any modern text editor that can read a UTF-8 encoded text file, but also ensures that if some or all of the logged data truely was UTF-8 encoded text, that it will be readable.  Any of this data can later be read from that log file and restored to its original binary format with `from_eutf8()` for further evaluation.

The only change that `to_eutf8()` makes to already valid UTF-8 encoded data with no C0 or C1 control codes other than horizontal tab (\t 0x09), line feed (\n 0x0A), and carriage return (\r 0x0D) characters, no private-use characters, and no noncharacters is that wherever a backslash (`\`) followed by zero or more UTF-8 encoded Zero Width Spaces and then two upper case hex digits is found in the source data, a three byte UTF-8 encoded Zero Width Space is inserted after the backslash.  This is done to ensure that `data == from_eutf8(to_eutf8(data))`, which might otherwise fail if a backslash and upper case hex characters present in `data` were misinterpreted as being an escape sequence.  UTF-8 encoding of U+200b is the three byte sequence `0xE2, 0x80, 0x8B`.  When printed/displayed, this Zero Width Space, as suggested by its name, is not visible.  Using this special Unicode character this way means that eutf8 encoding of already valid UTF-8 encoded text may be slightly expanded by adding three extra bytes for each occurance of this three-byte pattern.  However, if both the already valid UTF-8 encoded text and this corresponding eutf8 encoded data are both decoded and displayed, their appearance will be identical.  Note that some text editors may display some visible representation of U+200b to facilitate manual editing of text containing this special character.

A consequence of the handling of backslash characters followed by two upper case hex digits by `to_eutf8()` is that if `e8data` is eutf8 encoded, then mistakenly using `to_eutf8(e8data)` will insert a three-byte Zero Width Space for each three-byte escape sequence used in `e8data`.  Thus for arbitrary `data`, `data != from_eutf8(to_eutf8(to_eutf8(data)))` but `data == from_eutf8(from_eutf8(to_eutf8(to_eutf8(data)))`.  Also, mistakenly using `from_eutf8(data)` for arbitrary `data` is not necessarily reversible: `data != to_eutf8(from_eutf8(data))`.  This is because `from_eutf8()` assumes that the input is valid `eutf8` data produced by `to_eutf8`, and thus replaces sequences of text that appear to be eutf8 escape codes with the corresponding bytes.  If some of those bytes form valid UTF-8 encoded text (including ASCII text), then `to_eutf8()` will not undo the effects of `from_eutf8()`.

eutf8 encoded data is still considered valid if it includes escape sequences of the form `\HH` where that escaped byte would have been part of a sequence of valid UTF-8 encoded text.  `from_eutf8()` correctly handles such cases.  This also means that while `to_eutf8()` allows the user to choose whether or not horizontal tab, line feed, and carriage return characters are escaped, `from_eutf8()` handles all of these cases automatically.

Concatenating two valid eutf8 encoded sequences produces a valid eutf8 encoded sequence, as is also the case for concatenating two valid UTF-8 encoded sequences.  However, splitting a UTF-8 encoded byte sequence at an arbitrary byte boundary may produce sequences that are not valid UTF-8 sequences.  This can occur because a valid multi-byte UTF-8 character missing its leading or trailing bytes is not a valid UTF-8 character.  Since all eutf8 encoded sequences are also valid UTF-8 encoded sequences, this same property applies.  So, splitting an eutf8 encoded sequence at an arbitrary byte boundary may produce sequences that are not valid eutf8 sequences.


### Why use eutf8 encoded data instead of HEX or Base64?

Where arbitrary binary data must be converted to a printable form, conversion to hexidecimal or Base64 encoding are commonly used.  eutf8 encoded random binary data is slightly longer than converting that data to hex encoded bytes with no spaces.  In the worst case, where every byte of input must be escaped, eutf8 data is three times longer than the input, and 1.5 times longer than hex encoding without spaces.  So, hex encoded data (without spaces) is slightly smaller than eutf8 encoded random data, and Base64 encoding is even more compact.  These size comparisons are reversed if the data is mostly text rather than random binary data.  Neither hex nor Base64 encoding provides a good solution for printing data that is a mix of text and non-text bytes in cases where it would be advantageous for the text portions to be human readable.

This desirable feature of eutf8 is partially achieved in Python by printing bytes objects without first using `decode()` to convert them to text.  However, this only works well if the text is mostly ASCII bytes, as is typically the case for English and some romance languages.  If the bytes object contains multi-byte UTF-8 encoded characters such as are required for many other languages, then those multi-byte characters will all be printed as escape sequences, such that they are not human readable.

Where any text in the data to be encoded is expected to use only printable ASCII characters, [easc (escaped ASCII)](easc) encoding may be a better choice.  easc encoding is simpler and avoids displaying non-text bytes as uncommon Unicode chraracters when escape codes would have been more appropriate.  A disadvantage of easc over eutf8 is that, unlike eutf8, easc encoding of already valid printable ASCII text may slightly change its appearance when printed/displayed.
